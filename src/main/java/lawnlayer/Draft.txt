VERSION 1:

    private TileList fillStripFromLeft(TileList fillTiles, int y, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int x = start;

        while (x < end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x + tileSize, y);
            Tile above = new Tile(fillTiles.getTileSprite(), x, y - tileSize);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y - tileSize);
            
            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.RIGHT)) {
                
                int thickness = countHorizontalThickness(next, Direction.RIGHT);

                if (thickness % 2 != 0)
                    fill = !fill;
                x += thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {
                
                int thickness = countHorizontalThickness(next, Direction.RIGHT);
                
                if (current.getX() == tileSize)
                    thickness--;
                
                fill = !fill;
                x += (thickness - 1) * tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {

                fill = !fill;
            }
            x += tileSize;
        }
        return strip;
    }

    private TileList fillStripFromRight(TileList fillTiles, int y, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int x = start;

        while (x > end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x - tileSize, y);
            Tile above = new Tile(fillTiles.getTileSprite(), x, y - tileSize);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y + tileSize);
            
            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.LEFT)) {
            
                int thickness = countHorizontalThickness(next, Direction.LEFT);

                if (thickness % 2 != 0)
                    fill = !fill;
                x -= thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {

                int thickness = countHorizontalThickness(next, Direction.LEFT);

                fill = !fill;
                x -= (thickness - 1) * tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {
                fill = !fill;
            }
            x -= tileSize;
        }
        return strip;
    }

    private TileList fillStripFromTop(TileList fillTiles, int x, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int y = start;
        
        while (y < end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x, y + tileSize);
            Tile above = new Tile(fillTiles.getTileSprite(), x - tileSize, y);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y + tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y + tileSize);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.DOWN)) {
                
                int thickness = countVerticalThickness(next, Direction.DOWN);
                
                if (thickness % 2 != 0)
                    fill = !fill;
                y += thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {

                fill = !fill;
                y += tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {

                fill = !fill;
            }
            y += tileSize;
        }
        return strip;
    }

    private TileList fillStripFromBottom(TileList fillTiles, int x, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int y = start;

        while (y > end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x, y - tileSize);
            Tile above = new Tile(fillTiles.getTileSprite(), x - tileSize, y);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y - tileSize);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.UP)) {
                
                int thickness = countVerticalThickness(next, Direction.UP);
                
                if (thickness % 2 != 0)
                    fill = !fill;
                y -= thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {

                fill = !fill;
                y -= tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {

                fill = !fill;
            }
            y -= tileSize;
        }
        return strip;
    }

    private int countHorizontalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();
        
        while (true) {

            Tile current = new Tile(getTileSprite(), x, y);
            Tile above = new Tile(getTileSprite(), x, y - tileSize);
            Tile below = new Tile(getTileSprite(), x, y + tileSize);
            
            if (this.contains(current) &&
                (this.contains(above) ||
                this.contains(below))) {
                thickness += 1;
            } else
                break;
            
            if (d == Direction.RIGHT)
                x += tileSize;
            else
                x -= tileSize;
        }
        return thickness;
    }

    private int countVerticalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();
        
        while (true) {

            Tile positionTile = new Tile(getTileSprite(), x, y);
            
            if (this.contains(positionTile))
                thickness += 1;
            else
                break;
            
            if (d == Direction.DOWN)
                y += tileSize;
            else
                y -= tileSize;
        }
        return thickness;
    }

    private boolean isInsideRegion(Tile current, boolean fill) {

        return (!this.contains(current) && fill);
    }

    private boolean isEnteringThickRegion(Tile current, Tile next,
                                    Direction d) {

        Tile nextTile = this.getTile(next);

        if (d == Direction.LEFT || d == Direction.RIGHT)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    (nextTile.getOrientation() == Direction.UP ||
                    nextTile.getOrientation() == Direction.DOWN));
        
        if (d == Direction.UP || d == Direction.DOWN)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    (nextTile.getOrientation() == Direction.LEFT ||
                    nextTile.getOrientation() == Direction.RIGHT));

        return false;
    }

    private boolean isEnteringThinRegion(TileList fillTiles, Tile current, Tile next,
                                    Tile above, Tile aboveNext, Tile belowNext) {

        return (!this.contains(current) &&
                this.contains(next) &&
                !fillTiles.contains(above) &&
                (!this.contains(aboveNext) ||
                this.contains(belowNext)));
    }

    private boolean isExitingRegion(TileList fillTiles, Tile current,
                                    Tile next, Tile aboveNext) {

        return (this.contains(current) &&
                !this.contains(next) &&
                !fillTiles.contains(aboveNext));
    }

VERSION 2:

    private void fillHorizontally(TileList fillTiles, int start, int end) {

        boolean inEnclosedRegion = false;
        boolean inHorizontalRegion = false;
        
        Tile firstTile = tiles.get(0);
        Tile lastTile = tiles.get(tiles.size() - 1);

        int yMean = Math.abs(firstTile.getY() - lastTile.getY()) / 2;
        int right = Info.WIDTH - 2 * tileSize;

        if ((firstTile.getX() == tileSize && lastTile.getX() == right ||
            firstTile.getX() == right && lastTile.getX() == tileSize) &&
            firstTile.getY() + yMean < Info.HEIGHT / 2) {
            
            inEnclosedRegion = true;
            inHorizontalRegion = true;
        }
        for (int y = tileSize; y < Info.HEIGHT - tileSize; y += tileSize) {

            boolean fill = inEnclosedRegion;

            if ((y == firstTile.getY() || y == lastTile.getY()) &&
                !inEnclosedRegion && !inHorizontalRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
                fill = inEnclosedRegion;
            }
            else if ((y == firstTile.getY() || y == lastTile.getY()) &&
                inEnclosedRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
            }
            TileList strip = fillHorizontalStrip(fillTiles, y, start, end, fill);
            fillTiles.addAll(strip.toArray());
        }
    }

    private void fillVertically(TileList fillTiles, int start, int end) {

        boolean inEnclosedRegion = false;
        boolean inVerticalRegion = false;

        Tile firstTile = tiles.get(0);
        Tile lastTile = tiles.get(tiles.size() - 1);

        int xMean = Math.abs(firstTile.getX() - lastTile.getX()) / 2;
        int top = tileSize;
        int bottom = Info.HEIGHT - 2 * tileSize;

        if ((firstTile.getY() == top && lastTile.getY() == bottom ||
            firstTile.getY() == bottom && lastTile.getY() == top) &&
            firstTile.getX() + xMean < Info.WIDTH / 2) {

            inEnclosedRegion = true;
            inVerticalRegion = true;
        }
        for (int x = tileSize; x < Info.WIDTH - tileSize; x += tileSize) {

            boolean fill = inEnclosedRegion;

            if ((x == firstTile.getX() || x == lastTile.getX()) &&
                !inEnclosedRegion && !inVerticalRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
                fill = inEnclosedRegion;
            } 
            else if ((x == firstTile.getX() || x == lastTile.getX()) &&
                inEnclosedRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
            }
            TileList strip = fillVerticalStrip(fillTiles, x, start, end, fill);
            fillTiles.addAll(strip.toArray());
        }
    }

    private TileList fillHorizontalStrip(TileList fillTiles, int y, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int x = start;

        boolean condition = x < end;
        int incr = tileSize;
        Direction d = Direction.RIGHT;

        if (start > end) {

            condition = x > end;
            incr = -tileSize;
            d = Direction.LEFT;
        }
        while (condition) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x + incr, y);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x + incr, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + incr, y + tileSize);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isPassingThickBorder(current, next, aboveNext, belowNext, d)) {

                int thickness = countHorizontalThickness(next, d);

                if (thickness % 2 != 0)
                    fill = !fill;
                
                x += thickness * incr;
            }
            else if (isPassingThinBorder(current, next)) {

                fill = updateFill(fillTiles, next, aboveNext, d);
            }
            x += incr;
            
            if (start < end)
                condition = x < end;
            else
                condition = x > end;
        }
        return strip;
    }

    private TileList fillVerticalStrip(TileList fillTiles, int x, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int y = start;

        boolean condition = y < end;
        int incr = tileSize;
        Direction d = Direction.DOWN;
        
        if (start > end) {
            
            condition = y > end;
            incr = -tileSize;
            d = Direction.UP;
        }
        while (condition) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x, y + incr);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y + incr);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y + incr);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isPassingThickBorder(current, next, aboveNext, belowNext, d)) {
                
                int thickness = countVerticalThickness(next, d);

                if (thickness % 2 != 0)
                    fill = !fill;
                
                y += thickness * incr;
            }
            else if (isPassingThinBorder(current, next)) {

                fill = updateFill(fillTiles, next, aboveNext, d);
            }
            y += incr;

            if (start < end)
                condition = y < end;
            else
                condition = y > end;
        }
        return strip;
    }

    private int countHorizontalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();

        while (true) {

            Tile below = new Tile(getTileSprite(), x, y + tileSize);
            Tile current = new Tile(getTileSprite(), x, y);
            Tile above = new Tile(getTileSprite(), x, y - tileSize);            

            if (this.contains(below) &&
                this.contains(current) &&
                this.contains(above))

                thickness += 1;
            
            else break;

            if (d == Direction.RIGHT)
                x += tileSize;
            else
                x -= tileSize;
        }
        return thickness;
    }

    private int countVerticalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();

        while (true) {

            Tile below = new Tile(getTileSprite(), x + tileSize, y);
            Tile current = new Tile(getTileSprite(), x, y);
            Tile above = new Tile(getTileSprite(), x - tileSize, y);

            if (this.contains(below) &&
                this.contains(current) &&
                this.contains(above))
                
                thickness += 1;

            else break;

            if (d == Direction.DOWN)
                y += tileSize;
            else
                y -= tileSize;
        }
        return thickness;
    }

    private boolean isInsideRegion(Tile current, boolean fill) {

        return (!this.contains(current) && fill);
    }

    private boolean isPassingThickBorder(Tile current, Tile next,
            Tile aboveNext, Tile belowNext, Direction d) {

        Tile nextTile = get(next);

        if (d == Direction.LEFT || d == Direction.RIGHT)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    this.contains(aboveNext) &&
                    this.contains(belowNext) &&
                    (nextTile.getOrientation() == Direction.UP ||
                    nextTile.getOrientation() == Direction.DOWN));

        if (d == Direction.UP || d == Direction.DOWN)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    this.contains(aboveNext) &&
                    this.contains(belowNext) &&
                    (nextTile.getOrientation() == Direction.LEFT ||
                    nextTile.getOrientation() == Direction.RIGHT));

        return false;
    }

    private boolean isPassingThinBorder(Tile current, Tile next) {
        
        return (this.contains(current) && !this.contains(next));
    }

    private boolean updateFill(TileList fillTiles, Tile next, Tile aboveNext, Direction d) {

        if (this.contains(aboveNext)) {

            int x = next.getX();
            int y = next.getY();

            boolean condition = y < Info.HEIGHT - tileSize;;

            if (d == Direction.UP || d == Direction.DOWN)
                condition = x < Info.WIDTH - tileSize;

            while (condition) {

                Tile positionTile = new Tile(fillTiles.getTileSprite(), x, y);

                if (this.contains(positionTile))
                    return true;

                if (d == Direction.UP || d == Direction.DOWN) {
                    x += tileSize;
                    condition = x < Info.WIDTH - tileSize;
                }
                else {
                    y += tileSize;
                    condition = y < Info.HEIGHT - tileSize;
                }
            }
            return false;
        }
        else {

            return (fillTiles.contains(aboveNext));
        }
    }

    private int[][] getBounds() {

        int xUpper = tiles.get(0).getX();
        int xLower = tiles.get(0).getX();
        int yUpper = tiles.get(0).getY();
        int yLower = tiles.get(0).getY();

        for (Tile tile : tiles) {

            if (tile.getX() < xUpper)
                xUpper = tile.getX();
            else if (tile.getX() > xLower)
                xLower = tile.getX();

            if (tile.getY() < yUpper)
                yUpper = tile.getY();
            else if (tile.getY() > yLower)
                yLower = tile.getY();
        }
        return new int[][] {{xUpper, xLower}, {yUpper, yLower}};
    }

    public boolean isInsideRegion(TileList borderTiles, Direction direction) {

        int x = this.x;
        int y = this.y;
        boolean condition;
        int incr;

        switch (direction) {

            case UP:
                condition = y > 0;
                incr = -size;
                break;

            case DOWN:
                condition = y < (Info.HEIGHT - size);
                incr = size;
                break;

            case LEFT:
                condition = x > 0;
                incr = -size;
                break;

            case RIGHT:
                condition = x < (Info.WIDTH - size);
                incr = size;
                break;

            default:
                condition = false;
                incr = 0;
                break;
        }
        while (condition) {

            Tile positionTile = new Tile(sprite, x, y);

            if (borderTiles.contains(positionTile))
                return true;

            if (direction == Direction.UP || direction == Direction.DOWN) {
                y += incr;
                condition = updateCondition(y, direction);
            }
            else {
                x += incr;
                condition = updateCondition(x, direction);
            }
        }
        return false;
    }

    public void checkMissingTile(TileList otherTiles) {

        int missingTileX = 0;
        int missingTileY = 0;

        for (Tile tile : tiles) {

            if (tile.getX() == 2*tileSize) {
                missingTileX = tileSize;
                missingTileY = tile.getY();
            }
            if (tile.getX() == Info.WIDTH - 3*tileSize) {
                missingTileX = Info.WIDTH - 2*tileSize;
                missingTileY = tile.getY();
            }
            if (tile.getY() == 2*tileSize) {
                missingTileX = tile.getX();
                missingTileY = tileSize;
            }
            if (tile.getY() == Info.HEIGHT - 3*tileSize) {
                missingTileX = tile.getX();
                missingTileY = Info.HEIGHT - 2*tileSize;
            }
        }
        Tile missingTile = new Tile(getTileSprite(), missingTileX, missingTileY, Info.GREENPATH);
        Tile other = otherTiles.get(otherTiles.size() - 1);

        if (missingTile.isAdjacentTo(other))
            tiles.add(0, missingTile);
    }

    private void adjustMovementOnSoil() {

        int xDeviation = x % size;
        int yDeviation = y % size;

        if (direction == Direction.UP || direction == Direction.DOWN) {

            if (xDeviation < speed)
                x -= xDeviation;
            else if (size - xDeviation < speed)
                x += (size - xDeviation);
            else if (xDeviation < (size / 2))
                x -= speed;
            else
                x += speed;
        }
        if (direction == Direction.LEFT || direction == Direction.RIGHT) {
            
            if (yDeviation < speed)
                y -= yDeviation;
            else if (size - yDeviation < speed)
                y += (size - yDeviation);
            else if (yDeviation < (size / 2))
                y -= speed;
            else
                y += speed;
        }
    }

    

    private void fillUpwards(TileList scanTiles, TileList fillTiles) {

        for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

            for (int y = (Info.HEIGHT - 2*tileSize); y > 0; y -= tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.UP))

                    scanTiles.add(tile);

            }
        }
    }

    private void fillDownwards(TileList scanTiles, TileList fillTiles) {

        for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

            for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.DOWN))

                    scanTiles.add(tile);
            }
        }
    }

    private void fillLeftwards(TileList scanTiles, TileList fillTiles) {
        
        for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = (Info.WIDTH - 2*tileSize); x > 0; x -= tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.LEFT))

                    scanTiles.add(tile);
            }
        }
    }

    private void fillRightwards(TileList scanTiles, TileList fillTiles) {
        
        for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.RIGHT))

                    scanTiles.add(tile);
            }
        }
    }

    private void fillEnclosedTileSpace(List<Enemy> enemies) {

        TileList scanTiles = new TileList(this.getTileSprite());

        for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

                Tile tile = new Tile(this.getTileSprite(), x, y, Info.GRASS);

                boolean isRemovedTile = false;
                for (Enemy enemy : enemies) {

                    if (!(enemy instanceof Beetle))
                        continue;
                    
                    Beetle beetle = (Beetle) enemy;
                    if (beetle.removedTileList().contains(tile))
                        isRemovedTile = true;
                }
                if (isRemovedTile || this.contains(tile))
                    continue;

                int numOfSidesEnclosed = 0;

                if (tile.isInsideRegion(this, Direction.UP))
                    numOfSidesEnclosed++;
                
                if (tile.isInsideRegion(this, Direction.DOWN))
                    numOfSidesEnclosed++;

                if (tile.isInsideRegion(this, Direction.LEFT))
                    numOfSidesEnclosed++;

                if (tile.isInsideRegion(this, Direction.RIGHT))
                    numOfSidesEnclosed++;

                if (numOfSidesEnclosed >= 3)
                    scanTiles.add(tile);
            }
        }
        this.addAll(scanTiles.toArray());
    }

    private void parallelFillForAdjacentToFillTiles(TileList fillTiles,
        TileList secondScan, Tile headTile, Tile tailTile) {

        if (headTile.getY() == tileSize ||
            tailTile.getY() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.DOWN);
        
        if (headTile.getY() == Info.HEIGHT - 2*tileSize ||
            tailTile.getY() == Info.HEIGHT - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.UP);

        if (headTile.getX() == tileSize ||
            tailTile.getX() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.RIGHT);
        
        if (headTile.getX() == Info.WIDTH - 2*tileSize ||
            tailTile.getX() == Info.WIDTH - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.LEFT);
    }

        private void parallelFillForAdjacentToFillTiles(TileList fillTiles,
        TileList secondScan, Tile headTile, Tile tailTile) {

        if (headTile.getY() == tileSize ||
            tailTile.getY() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.DOWN);
        
        if (headTile.getY() == Info.HEIGHT - 2*tileSize ||
            tailTile.getY() == Info.HEIGHT - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.UP);

        if (headTile.getX() == tileSize ||
            tailTile.getX() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.RIGHT);
        
        if (headTile.getX() == Info.WIDTH - 2*tileSize ||
            tailTile.getX() == Info.WIDTH - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.LEFT);
    }

    
    private boolean updateCollisionWithConcrete(Map<Direction,Tile> boundTiles,
        Tile currentTile, TileList concreteTiles, TileList adjacentTiles) {
        
        Tile first = adjacentTiles.get(0);
        Tile second = adjacentTiles.get(1);
        Tile third = adjacentTiles.get(2);
        Tile fourth = adjacentTiles.get(3);

        boolean collidedWithConcrete = false;

        if (concreteTiles.contains(first)) {

            boundTiles.replace(first.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        if (concreteTiles.contains(second)) {

            boundTiles.replace(second.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        if (concreteTiles.contains(third)) {

            boundTiles.replace(third.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        if (concreteTiles.contains(fourth)) {

            boundTiles.replace(fourth.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        return collidedWithConcrete;
    }

    private TileList updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, TileList parameters, TileList adjacentTiles) {

        Tile start = parameters.get(0);
        Tile end = parameters.get(1);
        Tile currentTile = parameters.get(2);
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            start = tiles.get(tiles.size() - 1);
            end = tiles.get(0);
            currentTile = start;
        }
        return new TileList(new Tile[] {start, end, currentTile});
    }

    private boolean[] updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, Tile end, TileList adjacentTiles) {
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            reachedLimit = true;
            collidedWithConcrete = false;
        }
        return new boolean[] {reachedLimit, collidedWithConcrete};
    }

    
    private Tile updateCurrentTile(Tile currentTile, TileList fillTiles, TileList concreteTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        for (Tile tile : adjacentTiles.toArray()) {

            if (fillTiles.get(tile) != null &&
                fillTiles.get(tile).getOrientation() != Direction.NONE &&
                previousDirection != tile.getOppositeOrientation()) {
            
                currentTile = fillTiles.get(tile);
                break;
            }
        }
        for (Tile tile : adjacentTiles.toArray()) {

            if (concreteTiles.get(tile) != null &&
                previousDirection != tile.getOppositeOrientation())
                
                currentTile = concreteTiles.get(tile);
        }
        return currentTile;
    }

    private Direction updatePreviousDirection(TileList fillTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        Tile first = adjacentTiles.get(0);
        Tile second = adjacentTiles.get(1);
        Tile third = adjacentTiles.get(2);
        Tile fourth = adjacentTiles.get(3);

        if (fillTiles.get(first) != null &&
            fillTiles.get(first).getOrientation() != Direction.NONE &&
            previousDirection != first.getOppositeOrientation()) {
            
            previousDirection = first.getOrientation();
        }
        else if (fillTiles.get(second) != null &&
            fillTiles.get(second).getOrientation() != Direction.NONE &&
            previousDirection != second.getOppositeOrientation()) {
            
            previousDirection = second.getOrientation();
        }
        else if (fillTiles.get(third) != null &&
            fillTiles.get(third).getOrientation() != Direction.NONE &&
            previousDirection != third.getOppositeOrientation()) {
            
            previousDirection = third.getOrientation();
        }
        else if (fillTiles.get(fourth) != null &&
            fillTiles.get(fourth).getOrientation() != Direction.NONE &&
            previousDirection != fourth.getOppositeOrientation()) {
            
            previousDirection = fourth.getOrientation();
        }
        return previousDirection;
    }

    private int[][] getPathBounds() {

        int xUpper = tiles.get(0).getX();
        int xLower = tiles.get(0).getX();
        int yUpper = tiles.get(0).getY();
        int yLower = tiles.get(0).getY();

        for (Tile tile : tiles) {

            if (tile.getX() < xUpper)
                xUpper = tile.getX();
            else if (tile.getX() > xLower)
                xLower = tile.getX();

            if (tile.getY() < yUpper)
                yUpper = tile.getY();
            else if (tile.getY() > yLower)
                yLower = tile.getY();
        }
        return new int[][] {{xUpper, xLower}, {yUpper, yLower}};
    }

    private Tile updateCurrentTile(Tile currentTile, TileList fillTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        for (Tile tile : adjacentTiles.toArray()) {

            if (fillTiles.get(tile) != null &&
                fillTiles.get(tile).getOrientation() != Direction.NONE &&
                previousDirection != tile.getOppositeOrientation()) {
            
                currentTile = fillTiles.get(tile);
                break;
            }
        }
        return currentTile;
    }

    private Direction updatePreviousDirection(TileList fillTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        Tile first = adjacentTiles.get(0);
        Tile second = adjacentTiles.get(1);
        Tile third = adjacentTiles.get(2);
        Tile fourth = adjacentTiles.get(3);

        if (fillTiles.get(first) != null &&
            fillTiles.get(first).getOrientation() != Direction.NONE &&
            previousDirection != first.getOppositeOrientation()) {
            
            previousDirection = first.getOrientation();
        }
        else if (fillTiles.get(second) != null &&
            fillTiles.get(second).getOrientation() != Direction.NONE &&
            previousDirection != second.getOppositeOrientation()) {
            
            previousDirection = second.getOrientation();
        }
        else if (fillTiles.get(third) != null &&
            fillTiles.get(third).getOrientation() != Direction.NONE &&
            previousDirection != third.getOppositeOrientation()) {
            
            previousDirection = third.getOrientation();
        }
        else if (fillTiles.get(fourth) != null &&
            fillTiles.get(fourth).getOrientation() != Direction.NONE &&
            previousDirection != fourth.getOppositeOrientation()) {
            
            previousDirection = fourth.getOrientation();
        }
        return previousDirection;
    }

    private boolean updateCollisionWithConcrete(TileList concreteTiles,
        TileList adjacentTiles) {

        boolean collidedWithConcrete = false;
        
        for (Tile tile : adjacentTiles.toArray()) {

            if (concreteTiles.contains(tile)) {

                collidedWithConcrete = true;
                break;
            }
        }
        return collidedWithConcrete;
    }

    private TileList updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, TileList parameters, TileList adjacentTiles) {

        Tile start = parameters.get(0);
        Tile end = parameters.get(1);
        Tile currentTile = parameters.get(2);
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            start = tiles.get(tiles.size() - 1);
            end = tiles.get(0);
            currentTile = start;
        }
        return new TileList(new Tile[] {start, end, currentTile});
    }

    private boolean[] updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, Tile end, TileList adjacentTiles) {
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            reachedLimit = true;
            collidedWithConcrete = false;
        }
        return new boolean[] {reachedLimit, collidedWithConcrete};
    }

    public TileList getBounds(TileList fillTiles,
        TileList concreteTiles, Direction direction) {
        
        TileList bounds = new TileList();
        bounds.addAll(this, false);

        Tile current = tiles.get(0);
        Tile end = tiles.get(tiles.size() - 1);

        Direction previousDirection = Direction.NONE;
        boolean collidedWithConcrete = false;
        boolean reachedLimit = false;

        while (true) {

            System.out.println("Current tile: "+current);

            TileList adjacentTiles = getAdjacentTiles(current, direction);

            if (reachedLimit && (collidedWithConcrete ||
                adjacentTiles.contains(end))) {
                
                System.out.println("Reached the end");
                break;
            }
            for (Tile tile : adjacentTiles.toArray()) {

                if (fillTiles.get(tile) != null &&
                    fillTiles.get(tile).getOrientation() != Direction.NONE &&
                    previousDirection != tile.getOppositeOrientation()) {
                
                    current = tile;
                    bounds.add(current, false);
                    previousDirection = tile.getOrientation();
                    break;
                }
            }
            for (Tile tile : adjacentTiles.toArray()) {

                if (concreteTiles.contains(tile)) {
                    
                    collidedWithConcrete = true;
                    break;
                }
            }
            if (!reachedLimit && (collidedWithConcrete ||
                adjacentTiles.contains(end))) {

                current = tiles.get(tiles.size() - 1);
                end = tiles.get(0);
                reachedLimit = true;
                collidedWithConcrete = false;
            }
        }
        return bounds;
    }

    private TileList getAdjacentTiles(Tile currentTile, Direction direction) {

        Tile first = currentTile.getAdjacentTile(direction.flip());
        Tile second = currentTile.getAdjacentTile(first.getOppositeOrientation());
        Tile third = currentTile.getAdjacentTile(second.getPerpendicularOrientation());
        Tile fourth = currentTile.getAdjacentTile(first.getPerpendicularOrientation());

        return new TileList(new Tile[] {first, second, third, fourth});
    }

    private void fillForOppositeOrientiation(TileList fillTiles,
        TileList concreteTiles, Tile headTile, Tile tailTile, List<Enemy> enemies) {

        TileList scan1 = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());
        TileList scan2 = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());
        TileList scan3 = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());

        TileList bounds1 = getBounds(fillTiles, concreteTiles,
            headTile.getOrientation());
        // int[][] bounds2 = getBounds(fillTiles, concreteTiles,
        //     headTile.getPerpendicularOrientation());
        // int[][] bounds3 = getBounds(fillTiles, concreteTiles,
        //     tailTile.getPerpendicularOrientation());
        System.out.println(bounds1);

        // System.out.printf("%s: [%d,%d],[%d,%d]%n", headTile.getOrientation(), bounds1[0][0], bounds1[0][1], bounds1[1][0], bounds1[1][1]);
        // System.out.printf("%s: [%d,%d],[%d,%d]%n", headTile.getPerpendicularOrientation(), bounds2[0][0], bounds2[0][1], bounds2[1][0], bounds2[1][1]);
        // System.out.printf("%s: [%d,%d],[%d,%d]%n", tailTile.getPerpendicularOrientation(), bounds3[0][0], bounds3[0][1], bounds3[1][0], bounds3[1][1]);

        // fillInDirection(scan1, fillTiles, bounds1,
        //     headTile.getOrientation());
        // fillInDirection(scan2, fillTiles, bounds2,
        //     headTile.getPerpendicularOrientation());
        // fillInDirection(scan3, fillTiles, bounds3,
        //     tailTile.getPerpendicularOrientation());

        TileList defaultScan = new TileList();
        
        for (Tile tile : scan1.toArray()) {

            if (scan2.contains(tile) && scan3.contains(tile))
                defaultScan.add(tile, false);
        }
        for (Enemy enemy : enemies) {

            if (enemy.isInsideRegion(defaultScan)) {
                defaultScan.hide();
            }
        }
        fillTiles.addAll(defaultScan, isOverriding);
    }

    private void fillForPerpendicularOrientiation(TileList fillTiles,
        TileList concreteTiles, Tile headTile, Tile tailTile, List<Enemy> enemies) {

        TileList firstScan = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());
        TileList secondScan = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());

        TileList firstBounds = getBounds(fillTiles, concreteTiles,
            headTile.getOrientation());
        // int[][] secondBounds = getBounds(fillTiles, concreteTiles,
        //     tailTile.getOppositeOrientation());
        System.out.println(firstBounds);

        // System.out.printf("%s: [%d,%d],[%d,%d]%n", headTile.getOrientation(), firstBounds[0][0], firstBounds[0][1], firstBounds[1][0], firstBounds[1][1]);
        // System.out.printf("%s: [%d,%d],[%d,%d]%n", tailTile.getOppositeOrientation(), secondBounds[0][0], secondBounds[0][1], secondBounds[1][0], secondBounds[1][1]);

        // fillInDirection(firstScan, fillTiles, firstBounds,
        //     headTile.getOrientation());
        // fillInDirection(secondScan, fillTiles, secondBounds,
        //     tailTile.getOppositeOrientation());

        TileList scanTiles = new TileList();

        for (Tile tile : firstScan.toArray()) {

            if (secondScan.contains(tile))
                scanTiles.add(tile, false);
        }
        for (Enemy enemy : enemies) {

            if (enemy.isInsideRegion(scanTiles)) {
                scanTiles.hide();
            }
        }
        fillTiles.addAll(scanTiles, isOverriding);
    }

}

VERSION 3:

private void ascendingSort(TileList bounds, String xy) {

        int i = 0;
        while (i < bounds.size()) {

            Tile largest = bounds.get(i);

            for (int j = i; j < bounds.size(); j++) {

                Tile current = bounds.get(j);

                if ((xy.equals("X") &&
                    current.getX() > largest.getX()) ||
                    (xy.equals("Y") &&
                    current.getY() > largest.getY()))

                    largest = current;
            }
            bounds.remove(largest);
            bounds.add(0, largest);
            i++;
        }
    }

    private void descendingSort(TileList bounds, String xy) {

        int i = 0;
        while (i < bounds.size()) {

            Tile largest = bounds.get(0);

            for (int j = 0; j < (bounds.size() - i); j++) {

                Tile current = bounds.get(j);

                if ((xy.equals("X") &&
                    current.getX() > largest.getX()) ||
                    (xy.equals("Y") &&
                    current.getY() > largest.getY()))

                    largest = current;
            }
            bounds.remove(largest);
            bounds.add(bounds.size(), largest);
            i++;
        }
    }

    private void fillForOppositeHeadAndTail(TileList borderTiles,
        TileList fillTiles, TileList concreteTiles, Tile headTile,
        Tile tailTile, List<Enemy> enemies) {
        
        Direction direction = Direction.NONE;

        // Determine direction of bounds traversal
        
        if (headTile.getOrientation() == Direction.LEFT ||
            headTile.getOrientation() == Direction.RIGHT) {
            
            int distY = headTile.getY() - tailTile.getY();

            if (distY > 0)
                direction = Direction.UP;
            else
                direction = Direction.DOWN;
        }
        if (headTile.getOrientation() == Direction.UP ||
            headTile.getOrientation() == Direction.DOWN) {
            
            int distX = headTile.getX() - tailTile.getX();

            if (distX > 0)
                direction = Direction.LEFT;
            else
                direction = Direction.RIGHT;
        }
        TileList bounds = new TileList();
        int[][] limits;

        // Set up bounds for first scan

        bounds.addAll(this);
        getBounds(bounds, borderTiles, concreteTiles, headTile, tailTile,
            direction);
        getBounds(bounds, borderTiles, concreteTiles, tailTile, headTile,
            direction.flip());

        limits = bounds.getLimits();

        TileList firstScan =
            fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                tailTile.getOrientation());

        firstScan.removeRedundantStrips(bounds, concreteTiles,
            tailTile.getOrientation());
        firstScan.fillMissingStrips(bounds, borderTiles,
            concreteTiles);

        bounds.clear();

        // Set up bounds for second scan

        bounds.addAll(this);
        getBounds(bounds, borderTiles, concreteTiles, headTile, tailTile,
            direction.flip());
        getBounds(bounds, borderTiles, concreteTiles, tailTile, headTile,
            direction);

        limits = bounds.getLimits();

        TileList secondScan =
            fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                headTile.getOrientation());
        
        secondScan.removeRedundantStrips(bounds, concreteTiles,
            headTile.getOrientation());
        secondScan.fillMissingStrips(bounds, borderTiles,
            concreteTiles);

        // Retrieve regions from scans
        
        TileList[] regions = 
            getRegions(firstScan, secondScan, borderTiles, concreteTiles,
                bounds, enemies);
        
        fillTiles.addAll(regions[0]);
        fillTiles.addAll(regions[1]);
    }

    private void fillForNormalHeadAndTail(TileList borderTiles,
    TileList fillTiles, TileList concreteTiles, Tile headTile,
    Tile tailTile, List<Enemy> enemies) {
        
        Direction firstDirection = tailTile.getOrientation();
        Direction secondDirection = headTile.getOrientation();

        TileList bounds = new TileList();
        int[][] limits;

        // Set up bounds for first scan

        bounds.addAll(this);
        getBounds(bounds, borderTiles, concreteTiles, headTile, tailTile,
            firstDirection);
        getBounds(bounds, borderTiles, concreteTiles, tailTile, headTile,
            secondDirection);
        
        limits = bounds.getLimits();

        TileList firstScan =
            fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                firstDirection);

        firstScan.removeRedundantStrips(bounds, concreteTiles,
            firstDirection);
        firstScan.fillMissingStrips(bounds, borderTiles,
            concreteTiles);

        if (!firstScan.isEnclosed(borderTiles, concreteTiles, bounds))
            firstScan =
                fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                    secondDirection.flip());

        bounds.clear();

        // Set up bounds for second scan

        bounds.addAll(this);
        getBounds(bounds, borderTiles, concreteTiles, headTile, tailTile,
            firstDirection.flip());
        getBounds(bounds, borderTiles, concreteTiles, tailTile, headTile,
            secondDirection.flip());

        limits = bounds.getLimits();

        TileList secondScan =
            fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                firstDirection.flip());

        secondScan.removeRedundantStrips(bounds, concreteTiles,
            firstDirection.flip());
        secondScan.fillMissingStrips(bounds, borderTiles,
            concreteTiles);

        if (!secondScan.isEnclosed(borderTiles, concreteTiles, bounds))
            secondScan =
                fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                    secondDirection);
        
        // Retrieve regions from scans

        TileList[] regions = 
            getRegions(firstScan, secondScan, borderTiles, concreteTiles,
                bounds, enemies);
        
        fillTiles.addAll(regions[0]);
        fillTiles.addAll(regions[1]);
    }

    private void fillForParallelHeadAndTail(TileList borderTiles,
        TileList fillTiles, TileList concreteTiles, Tile headTile,
        Tile tailTile, List<Enemy> enemies) {

        Direction direction = headTile.getOrientation().normal();

        TileList bounds = new TileList(fillTiles.getTileSprite(), Info.GRASS);
        int[][] limits = new int[2][2];

        // Determine limits

        if (direction == Direction.UP ||
            direction == Direction.DOWN)
            limits =
                new int[][] {{0, 0}, {Info.TOPBAR, Info.HEIGHT - tileSize}};

        if (direction == Direction.LEFT ||
            direction == Direction.RIGHT)
            limits =
                new int[][] {{0, Info.WIDTH - tileSize}, {0, 0}};

        // Set up bounds for first scan

        bounds.addAll(this);
        getBounds(bounds, borderTiles, concreteTiles, headTile, tailTile,
            headTile.getOrientation());

        TileList firstScan =
            fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                direction);

        firstScan.removeRedundantStrips(bounds, concreteTiles,
            direction);
        firstScan.fillMissingStrips(bounds, borderTiles,
            concreteTiles);
        
        bounds.clear();

        // Set up bounds for second scan

        bounds.addAll(this);
        getBounds(bounds, borderTiles, concreteTiles, headTile, tailTile,
            headTile.getOppositeOrientation());

        TileList secondScan =
            fillInsideRegion(bounds, borderTiles, concreteTiles, limits,
                direction.flip());
        
        secondScan.removeRedundantStrips(bounds, concreteTiles,
            direction.flip());
        secondScan.fillMissingStrips(bounds, borderTiles,
            concreteTiles);
        
        // Retrieve regions from scans
        
        TileList[] regions = 
            getRegions(firstScan, secondScan, borderTiles, concreteTiles,
                bounds, enemies);
        
        fillTiles.addAll(regions[0]);
        fillTiles.addAll(regions[1]);
    }

    private TileList fillInsideRegion(TileList bounds, TileList borderTiles,
        TileList concreteTiles, int[][] limits, Direction direction) {
        
        TileList regionTiles =
            new TileList(borderTiles.getTileSprite(), Info.GRASS);

        switch (direction) {

            case LEFT:
                descendingSort(bounds, "X");
                break;
            case RIGHT:
                ascendingSort(bounds, "X");
                break;
            case UP:
                descendingSort(bounds, "Y");
                break;
            case DOWN:
                ascendingSort(bounds, "Y");
                break;
            default:
                break;
        }
        for (Tile bound : bounds.toArray()) {

            TileList strip;

            switch (direction) {

                case LEFT:
                    strip =
                        fillStripLeftwards(bound, regionTiles, borderTiles,
                            concreteTiles, limits[0][0]);
                    break;
                case RIGHT:
                    strip =
                        fillStripRightwards(bound, regionTiles, borderTiles,
                            concreteTiles, limits[0][1]);
                    break;
                case UP:
                    strip =
                        fillStripUpwards(bound, regionTiles, borderTiles,
                            concreteTiles, limits[1][0]);
                    break;
                case DOWN:
                    strip =
                        fillStripDownwards(bound, regionTiles, borderTiles,
                            concreteTiles, limits[1][1]);
                    break;
                default:
                    strip = new TileList();
                    break;
            }
            regionTiles.addAll(strip);
        }
        return regionTiles;
    }

    private TileList fillOutsideRegion(TileList firstRegion,
        TileList borderTiles, TileList concreteTiles) {

        TileList regionTiles =
            new TileList(borderTiles.getTileSprite(), Info.GRASS);
        
        for (int y = Info.TOPBAR; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = 0; x < (Info.WIDTH - tileSize); x += tileSize) {

                Tile positionTile =
                    new Tile(borderTiles.getTileSprite(), x, y, Info.GRASS);

                if (!firstRegion.contains(positionTile) &&
                    !borderTiles.contains(positionTile) &&
                    !concreteTiles.contains(positionTile))

                    regionTiles.add(positionTile);
            }
        }
        return regionTiles;
    }

    private void fillMissingStrips(TileList bounds, TileList borderTiles,
        TileList concreteTiles) {
        
        int i = 0;
        while (i < tiles.size()) {

            Tile tile = tiles.get(i);
            TileList adjacentTiles = tile.getAdjacentTiles();

            for (Tile adjacentTile : adjacentTiles.toArray()) {

                if (!this.contains(adjacentTile) &&
                    !bounds.contains(adjacentTile) &&
                    !borderTiles.contains(adjacentTile) &&
                    !concreteTiles.contains(adjacentTile))
                    
                    tiles.add(adjacentTile);
            } 
            i++;
        }
    }

    private TileList fillStripDownwards(Tile bound, TileList regionTiles,
        TileList borderTiles, TileList concreteTiles, int limit) {
        
        TileList strip = new TileList();
        Tile up = bound.getAdjacentTile(Direction.UP);

        if (this.contains(up) ||
            regionTiles.contains(up) ||
            borderTiles.contains(up))
            return strip;
        
        int x = bound.getX();
        
        for (int y = (bound.getY() + tileSize); y < limit; y += tileSize) {

            Tile newTile =
                new Tile(borderTiles.getTileSprite(), x, y, Info.GRASS);

            if (this.contains(newTile) ||
                concreteTiles.contains(newTile) ||
                borderTiles.contains(newTile))
                break;

            strip.add(newTile);
        }
        return strip;
    }

    private TileList fillStripLeftwards(Tile bound, TileList regionTiles,
        TileList borderTiles, TileList concreteTiles, int limit) {
        
        TileList strip = new TileList();
        Tile right = bound.getAdjacentTile(Direction.RIGHT);

        if (this.contains(right) ||
            regionTiles.contains(right) ||
            borderTiles.contains(right))
            return strip;
        
        int y = bound.getY();
        
        for (int x = (bound.getX() - tileSize); x > limit; x -= tileSize) {

            Tile newTile =
                new Tile(borderTiles.getTileSprite(), x, y, Info.GRASS);

            if (this.contains(newTile) ||
                concreteTiles.contains(newTile) ||
                borderTiles.contains(newTile))
                break;
            
            strip.add(newTile);
        }
        return strip;
    }

    private TileList fillStripRightwards(Tile bound, TileList regionTiles,
        TileList borderTiles, TileList concreteTiles, int limit) {
        
        TileList strip = new TileList();
        Tile left = bound.getAdjacentTile(Direction.LEFT);

        if (this.contains(left) ||
            regionTiles.contains(left) ||
            borderTiles.contains(left))
            return strip;
        
        int y = bound.getY();
        
        for (int x = (bound.getX() + tileSize); x < limit; x += tileSize) {

            Tile newTile =
                new Tile(borderTiles.getTileSprite(), x, y, Info.GRASS);

            if (this.contains(newTile) ||
                concreteTiles.contains(newTile) ||
                borderTiles.contains(newTile))
                break;
            
            strip.add(newTile);
        }
        return strip;
    }

    private TileList fillStripUpwards(Tile bound, TileList regionTiles,
        TileList borderTiles, TileList concreteTiles, int limit) {
        
        TileList strip = new TileList();
        Tile down = bound.getAdjacentTile(Direction.DOWN);

        if (this.contains(down) ||
            regionTiles.contains(down) ||
            borderTiles.contains(down))
            return strip;
        
        int x = bound.getX();
        
        for (int y = (bound.getY() - tileSize); y > limit; y -= tileSize) {

            Tile newTile =
                new Tile(borderTiles.getTileSprite(), x, y, Info.GRASS);

            if (this.contains(newTile) ||
                concreteTiles.contains(newTile) ||
                borderTiles.contains(newTile))
                break;

            strip.add(newTile);
        }
        return strip;
    }

    public void getBounds(TileList bounds, TileList borderTiles,
        TileList concreteTiles, Tile start, Tile end, Direction direction) {

        Tile current = start;
        Direction previousDirection = Direction.NONE;
        boolean collidedWithConcrete = false;

        while (true) {

            boolean hasUpdated = false;
            TileList directionTiles = getDirectionTiles(current, direction);
            
            for (Tile tile : directionTiles.toArray()) {

                if (borderTiles.get(tile) != null &&
                    previousDirection != tile.getOppositeOrientation()) {
                
                    current = tile;
                    bounds.add(current);
                    previousDirection = tile.getOrientation();
                    hasUpdated = true;
                    break;
                }
            }
            for (Tile tile : directionTiles.toArray()) {

                if (concreteTiles.contains(tile)) {
                    
                    collidedWithConcrete = true;
                    hasUpdated = true;
                    break;
                }
            }
            if (!hasUpdated ||
                collidedWithConcrete ||
                directionTiles.contains(end))
                break;
        }
    }

    private TileList getDirectionTiles(Tile currentTile, Direction direction) {

        Tile first = currentTile.getAdjacentTile(direction);
        Tile second = currentTile.getAdjacentTile(direction.normal());
        Tile third = currentTile.getAdjacentTile(direction.normal().flip());
        Tile fourth = currentTile.getAdjacentTile(direction.normal());

        return new TileList(new Tile[] {first, second, third, fourth});
    }

    private int[][] getLimits() {

        int xUpper = tiles.get(0).getX();
        int xLower = tiles.get(0).getX();
        int yUpper = tiles.get(0).getY();
        int yLower = tiles.get(0).getY();

        for (Tile tile : tiles) {

            if (tile.getX() < xUpper)
                xUpper = tile.getX();
            else if (tile.getX() > xLower)
                xLower = tile.getX();

            if (tile.getY() < yUpper)
                yUpper = tile.getY();
            else if (tile.getY() > yLower)
                yLower = tile.getY();
        }
        return new int[][] {{xUpper - tileSize, xLower + tileSize},
                            {yUpper - tileSize, yLower + tileSize}};
    }

    private TileList[] getRegions(TileList firstScan, TileList secondScan,
        TileList borderTiles, TileList concreteTiles, TileList bounds,
        List<Enemy> enemies) {

        TileList firstRegion;
        TileList secondRegion;

        if (firstScan.isEnclosed(borderTiles, concreteTiles, bounds) &&
            secondScan.isEnclosed(borderTiles, concreteTiles, bounds)) {
            
            firstRegion = firstScan;
            secondRegion = secondScan;
        }
        else if (firstScan.isEnclosed(borderTiles, concreteTiles, bounds) ||
            secondScan.equals(firstScan)) {

            firstRegion = firstScan;
            secondRegion = fillOutsideRegion(firstRegion, borderTiles,
                concreteTiles);
        }
        else if (secondScan.isEnclosed(borderTiles, concreteTiles, bounds)) {

            secondRegion = secondScan;
            firstRegion = fillOutsideRegion(secondRegion, borderTiles,
                concreteTiles);
        }
        else {

            firstRegion = new TileList();
            secondRegion = new TileList();
        }
        for (Enemy enemy : enemies) {

            if (enemy.isInsideRegion(firstRegion))
                firstRegion.clear();
            
            if (enemy.isInsideRegion(secondRegion))
                secondRegion.clear();
        }
        return new TileList[] { firstRegion, secondRegion };
    }

    private boolean isEnclosed(TileList borderTiles, TileList concreteTiles,
        TileList bounds) {

        if (tiles.isEmpty())
            return false;
        
        for (Tile tile : tiles) {

            TileList adjacentTiles = tile.getAdjacentTiles();

            for (Tile adjacentTile : adjacentTiles.toArray()) {

                if (!this.contains(adjacentTile) &&
                    !borderTiles.contains(adjacentTile) &&
                    !concreteTiles.contains(adjacentTile) &&
                    !bounds.contains(adjacentTile))
                    
                    return false;
            }
        }
        return true;
    }

    private void removeRedundantStrips(TileList bounds,
        TileList concreteTiles, Direction direction) {
        
        int i = 0;
        while (i < tiles.size()) {

            Tile tile = tiles.get(i);
            
            TileList adjacentTiles = new TileList();
            adjacentTiles.add(tile.getAdjacentTile(direction.normal()));
            adjacentTiles.add(tile.getAdjacentTile(direction.normal().flip()));

            int sides = 0;
            boolean tileIsRemoved = false;

            for (Tile adjacentTile : adjacentTiles.toArray()) {

                if (!tiles.contains(adjacentTile) &&
                    !bounds.contains(adjacentTile) &&
                    !concreteTiles.contains(adjacentTile)) {
                    sides++;
                }
                if (sides >= 2) {
                    tiles.remove(tile);
                    tileIsRemoved = true;
                }
            }
            if (!tileIsRemoved)
                i++;
        }
    }

    private boolean isClosedOffBy(TileList borderTiles,
        TileList concreteTiles) {

        if (!isEmpty() &&
            !isAllAdjacentTo(concreteTiles) &&
            !isAllAdjacentTo(borderTiles))

            return headAndTailAreAdjacentTo(borderTiles, concreteTiles);

        else if (!isEmpty() &&
            (isAllAdjacentTo(concreteTiles) ||
            isAllAdjacentTo(borderTiles))) {

            Tile headTile = tiles.get(0);
            Direction headDirection = headTile.getOrientation();

            Tile adjacentTile1 =
                headTile.getAdjacentTile(headDirection);
            Tile adjacentTile2 =
                headTile.getAdjacentTile(headDirection.flip());

            return ((borderTiles.contains(adjacentTile1) ||
                    concreteTiles.contains(adjacentTile1)) &&
                    (borderTiles.contains(adjacentTile2) ||
                    concreteTiles.contains(adjacentTile2)));
        }
        return false;
    }

    private boolean headAndTailAreAdjacentTo(TileList borderTiles,
        TileList otherTiles) {

        Tile headTile = tiles.get(0);
        Tile tailTile = tiles.get(tiles.size() - 1);

        boolean tailIsAdjacent = false;
        boolean headIsAdjacent = false;

        for (Tile tile : otherTiles.toArray()) {

            if (headTile.isAdjacentTo(tile))
                headIsAdjacent = true;
        }
        for (Tile tile : borderTiles.toArray()) {

            if (headTile.isAdjacentTo(tile))
                headIsAdjacent = true;
        }
        for (Tile tile : otherTiles.toArray()) {

            if (tailTile.isAdjacentTo(tile))
                tailIsAdjacent = true;
        }
        for (Tile tile : borderTiles.toArray()) {

            if (tailTile.isAdjacentTo(tile) &&
                !headTile.equals(tailTile))
                tailIsAdjacent = true;
        }
        return (tailIsAdjacent && headIsAdjacent);
    }

    private boolean isAllAdjacentTo(TileList otherTiles) {

        for (Tile tile : tiles) {

            if (!tile.isAdjacentTo(otherTiles))
                return false;
        }
        return true;
    }

    public boolean isAdjacentTo(Tile other) {

        return (Math.abs(x - other.getX()) == size && y == other.getY() ||
                Math.abs(y - other.getY()) == size && x == other.getX());
    }

    public boolean isAdjacentTo(TileList otherTiles) {

        for (Tile other : otherTiles.toArray()) {

            if (isAdjacentTo(other))
                return true;
        }
        return false;
    }

    public boolean isAdjacentTo(TileList otherTiles1, TileList otherTiles2) {

        return (isAdjacentTo(otherTiles1) || isAdjacentTo(otherTiles2));
    }