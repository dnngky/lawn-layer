VERSION 1:

    private TileList fillStripFromLeft(TileList fillTiles, int y, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int x = start;

        while (x < end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x + tileSize, y);
            Tile above = new Tile(fillTiles.getTileSprite(), x, y - tileSize);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y - tileSize);
            
            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.RIGHT)) {
                
                int thickness = countHorizontalThickness(next, Direction.RIGHT);

                if (thickness % 2 != 0)
                    fill = !fill;
                x += thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {
                
                int thickness = countHorizontalThickness(next, Direction.RIGHT);
                
                if (current.getX() == tileSize)
                    thickness--;
                
                fill = !fill;
                x += (thickness - 1) * tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {

                fill = !fill;
            }
            x += tileSize;
        }
        return strip;
    }

    private TileList fillStripFromRight(TileList fillTiles, int y, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int x = start;

        while (x > end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x - tileSize, y);
            Tile above = new Tile(fillTiles.getTileSprite(), x, y - tileSize);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y + tileSize);
            
            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.LEFT)) {
            
                int thickness = countHorizontalThickness(next, Direction.LEFT);

                if (thickness % 2 != 0)
                    fill = !fill;
                x -= thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {

                int thickness = countHorizontalThickness(next, Direction.LEFT);

                fill = !fill;
                x -= (thickness - 1) * tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {
                fill = !fill;
            }
            x -= tileSize;
        }
        return strip;
    }

    private TileList fillStripFromTop(TileList fillTiles, int x, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int y = start;
        
        while (y < end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x, y + tileSize);
            Tile above = new Tile(fillTiles.getTileSprite(), x - tileSize, y);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y + tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y + tileSize);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.DOWN)) {
                
                int thickness = countVerticalThickness(next, Direction.DOWN);
                
                if (thickness % 2 != 0)
                    fill = !fill;
                y += thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {

                fill = !fill;
                y += tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {

                fill = !fill;
            }
            y += tileSize;
        }
        return strip;
    }

    private TileList fillStripFromBottom(TileList fillTiles, int x, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int y = start;

        while (y > end) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x, y - tileSize);
            Tile above = new Tile(fillTiles.getTileSprite(), x - tileSize, y);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y - tileSize);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isEnteringThickRegion(current, next, Direction.UP)) {
                
                int thickness = countVerticalThickness(next, Direction.UP);
                
                if (thickness % 2 != 0)
                    fill = !fill;
                y -= thickness * tileSize;
            }
            else if (isEnteringThinRegion(fillTiles, current, next,
                                    above, aboveNext, belowNext)) {

                fill = !fill;
                y -= tileSize;
            }
            else if (isExitingRegion(fillTiles, current, next, aboveNext)) {

                fill = !fill;
            }
            y -= tileSize;
        }
        return strip;
    }

    private int countHorizontalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();
        
        while (true) {

            Tile current = new Tile(getTileSprite(), x, y);
            Tile above = new Tile(getTileSprite(), x, y - tileSize);
            Tile below = new Tile(getTileSprite(), x, y + tileSize);
            
            if (this.contains(current) &&
                (this.contains(above) ||
                this.contains(below))) {
                thickness += 1;
            } else
                break;
            
            if (d == Direction.RIGHT)
                x += tileSize;
            else
                x -= tileSize;
        }
        return thickness;
    }

    private int countVerticalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();
        
        while (true) {

            Tile positionTile = new Tile(getTileSprite(), x, y);
            
            if (this.contains(positionTile))
                thickness += 1;
            else
                break;
            
            if (d == Direction.DOWN)
                y += tileSize;
            else
                y -= tileSize;
        }
        return thickness;
    }

    private boolean isInsideRegion(Tile current, boolean fill) {

        return (!this.contains(current) && fill);
    }

    private boolean isEnteringThickRegion(Tile current, Tile next,
                                    Direction d) {

        Tile nextTile = this.getTile(next);

        if (d == Direction.LEFT || d == Direction.RIGHT)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    (nextTile.getOrientation() == Direction.UP ||
                    nextTile.getOrientation() == Direction.DOWN));
        
        if (d == Direction.UP || d == Direction.DOWN)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    (nextTile.getOrientation() == Direction.LEFT ||
                    nextTile.getOrientation() == Direction.RIGHT));

        return false;
    }

    private boolean isEnteringThinRegion(TileList fillTiles, Tile current, Tile next,
                                    Tile above, Tile aboveNext, Tile belowNext) {

        return (!this.contains(current) &&
                this.contains(next) &&
                !fillTiles.contains(above) &&
                (!this.contains(aboveNext) ||
                this.contains(belowNext)));
    }

    private boolean isExitingRegion(TileList fillTiles, Tile current,
                                    Tile next, Tile aboveNext) {

        return (this.contains(current) &&
                !this.contains(next) &&
                !fillTiles.contains(aboveNext));
    }

VERSION 2:

    private void fillHorizontally(TileList fillTiles, int start, int end) {

        boolean inEnclosedRegion = false;
        boolean inHorizontalRegion = false;
        
        Tile firstTile = tiles.get(0);
        Tile lastTile = tiles.get(tiles.size() - 1);

        int yMean = Math.abs(firstTile.getY() - lastTile.getY()) / 2;
        int right = Info.WIDTH - 2 * tileSize;

        if ((firstTile.getX() == tileSize && lastTile.getX() == right ||
            firstTile.getX() == right && lastTile.getX() == tileSize) &&
            firstTile.getY() + yMean < Info.HEIGHT / 2) {
            
            inEnclosedRegion = true;
            inHorizontalRegion = true;
        }
        for (int y = tileSize; y < Info.HEIGHT - tileSize; y += tileSize) {

            boolean fill = inEnclosedRegion;

            if ((y == firstTile.getY() || y == lastTile.getY()) &&
                !inEnclosedRegion && !inHorizontalRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
                fill = inEnclosedRegion;
            }
            else if ((y == firstTile.getY() || y == lastTile.getY()) &&
                inEnclosedRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
            }
            TileList strip = fillHorizontalStrip(fillTiles, y, start, end, fill);
            fillTiles.addAll(strip.toArray());
        }
    }

    private void fillVertically(TileList fillTiles, int start, int end) {

        boolean inEnclosedRegion = false;
        boolean inVerticalRegion = false;

        Tile firstTile = tiles.get(0);
        Tile lastTile = tiles.get(tiles.size() - 1);

        int xMean = Math.abs(firstTile.getX() - lastTile.getX()) / 2;
        int top = tileSize;
        int bottom = Info.HEIGHT - 2 * tileSize;

        if ((firstTile.getY() == top && lastTile.getY() == bottom ||
            firstTile.getY() == bottom && lastTile.getY() == top) &&
            firstTile.getX() + xMean < Info.WIDTH / 2) {

            inEnclosedRegion = true;
            inVerticalRegion = true;
        }
        for (int x = tileSize; x < Info.WIDTH - tileSize; x += tileSize) {

            boolean fill = inEnclosedRegion;

            if ((x == firstTile.getX() || x == lastTile.getX()) &&
                !inEnclosedRegion && !inVerticalRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
                fill = inEnclosedRegion;
            } 
            else if ((x == firstTile.getX() || x == lastTile.getX()) &&
                inEnclosedRegion) {
                
                inEnclosedRegion = !inEnclosedRegion;
            }
            TileList strip = fillVerticalStrip(fillTiles, x, start, end, fill);
            fillTiles.addAll(strip.toArray());
        }
    }

    private TileList fillHorizontalStrip(TileList fillTiles, int y, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int x = start;

        boolean condition = x < end;
        int incr = tileSize;
        Direction d = Direction.RIGHT;

        if (start > end) {

            condition = x > end;
            incr = -tileSize;
            d = Direction.LEFT;
        }
        while (condition) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x + incr, y);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x + incr, y - tileSize);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + incr, y + tileSize);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isPassingThickBorder(current, next, aboveNext, belowNext, d)) {

                int thickness = countHorizontalThickness(next, d);

                if (thickness % 2 != 0)
                    fill = !fill;
                
                x += thickness * incr;
            }
            else if (isPassingThinBorder(current, next)) {

                fill = updateFill(fillTiles, next, aboveNext, d);
            }
            x += incr;
            
            if (start < end)
                condition = x < end;
            else
                condition = x > end;
        }
        return strip;
    }

    private TileList fillVerticalStrip(TileList fillTiles, int x, int start, int end, boolean fill) {

        TileList strip = new TileList(fillTiles.getTileSprite());
        int y = start;

        boolean condition = y < end;
        int incr = tileSize;
        Direction d = Direction.DOWN;
        
        if (start > end) {
            
            condition = y > end;
            incr = -tileSize;
            d = Direction.UP;
        }
        while (condition) {

            Tile current = new Tile(fillTiles.getTileSprite(), x, y);
            Tile next = new Tile(fillTiles.getTileSprite(), x, y + incr);
            Tile aboveNext = new Tile(fillTiles.getTileSprite(), x - tileSize, y + incr);
            Tile belowNext = new Tile(fillTiles.getTileSprite(), x + tileSize, y + incr);

            if (isInsideRegion(current, fill))

                strip.add(current);

            if (isPassingThickBorder(current, next, aboveNext, belowNext, d)) {
                
                int thickness = countVerticalThickness(next, d);

                if (thickness % 2 != 0)
                    fill = !fill;
                
                y += thickness * incr;
            }
            else if (isPassingThinBorder(current, next)) {

                fill = updateFill(fillTiles, next, aboveNext, d);
            }
            y += incr;

            if (start < end)
                condition = y < end;
            else
                condition = y > end;
        }
        return strip;
    }

    private int countHorizontalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();

        while (true) {

            Tile below = new Tile(getTileSprite(), x, y + tileSize);
            Tile current = new Tile(getTileSprite(), x, y);
            Tile above = new Tile(getTileSprite(), x, y - tileSize);            

            if (this.contains(below) &&
                this.contains(current) &&
                this.contains(above))

                thickness += 1;
            
            else break;

            if (d == Direction.RIGHT)
                x += tileSize;
            else
                x -= tileSize;
        }
        return thickness;
    }

    private int countVerticalThickness(Tile tile, Direction d) {

        int thickness = 0;
        int x = tile.getX();
        int y = tile.getY();

        while (true) {

            Tile below = new Tile(getTileSprite(), x + tileSize, y);
            Tile current = new Tile(getTileSprite(), x, y);
            Tile above = new Tile(getTileSprite(), x - tileSize, y);

            if (this.contains(below) &&
                this.contains(current) &&
                this.contains(above))
                
                thickness += 1;

            else break;

            if (d == Direction.DOWN)
                y += tileSize;
            else
                y -= tileSize;
        }
        return thickness;
    }

    private boolean isInsideRegion(Tile current, boolean fill) {

        return (!this.contains(current) && fill);
    }

    private boolean isPassingThickBorder(Tile current, Tile next,
            Tile aboveNext, Tile belowNext, Direction d) {

        Tile nextTile = get(next);

        if (d == Direction.LEFT || d == Direction.RIGHT)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    this.contains(aboveNext) &&
                    this.contains(belowNext) &&
                    (nextTile.getOrientation() == Direction.UP ||
                    nextTile.getOrientation() == Direction.DOWN));

        if (d == Direction.UP || d == Direction.DOWN)

            return (!this.contains(current) &&
                    this.contains(next) &&
                    this.contains(aboveNext) &&
                    this.contains(belowNext) &&
                    (nextTile.getOrientation() == Direction.LEFT ||
                    nextTile.getOrientation() == Direction.RIGHT));

        return false;
    }

    private boolean isPassingThinBorder(Tile current, Tile next) {
        
        return (this.contains(current) && !this.contains(next));
    }

    private boolean updateFill(TileList fillTiles, Tile next, Tile aboveNext, Direction d) {

        if (this.contains(aboveNext)) {

            int x = next.getX();
            int y = next.getY();

            boolean condition = y < Info.HEIGHT - tileSize;;

            if (d == Direction.UP || d == Direction.DOWN)
                condition = x < Info.WIDTH - tileSize;

            while (condition) {

                Tile positionTile = new Tile(fillTiles.getTileSprite(), x, y);

                if (this.contains(positionTile))
                    return true;

                if (d == Direction.UP || d == Direction.DOWN) {
                    x += tileSize;
                    condition = x < Info.WIDTH - tileSize;
                }
                else {
                    y += tileSize;
                    condition = y < Info.HEIGHT - tileSize;
                }
            }
            return false;
        }
        else {

            return (fillTiles.contains(aboveNext));
        }
    }

    private int[][] getBounds() {

        int xUpper = tiles.get(0).getX();
        int xLower = tiles.get(0).getX();
        int yUpper = tiles.get(0).getY();
        int yLower = tiles.get(0).getY();

        for (Tile tile : tiles) {

            if (tile.getX() < xUpper)
                xUpper = tile.getX();
            else if (tile.getX() > xLower)
                xLower = tile.getX();

            if (tile.getY() < yUpper)
                yUpper = tile.getY();
            else if (tile.getY() > yLower)
                yLower = tile.getY();
        }
        return new int[][] {{xUpper, xLower}, {yUpper, yLower}};
    }

    public boolean isInsideRegion(TileList borderTiles, Direction direction) {

        int x = this.x;
        int y = this.y;
        boolean condition;
        int incr;

        switch (direction) {

            case UP:
                condition = y > 0;
                incr = -size;
                break;

            case DOWN:
                condition = y < (Info.HEIGHT - size);
                incr = size;
                break;

            case LEFT:
                condition = x > 0;
                incr = -size;
                break;

            case RIGHT:
                condition = x < (Info.WIDTH - size);
                incr = size;
                break;

            default:
                condition = false;
                incr = 0;
                break;
        }
        while (condition) {

            Tile positionTile = new Tile(sprite, x, y);

            if (borderTiles.contains(positionTile))
                return true;

            if (direction == Direction.UP || direction == Direction.DOWN) {
                y += incr;
                condition = updateCondition(y, direction);
            }
            else {
                x += incr;
                condition = updateCondition(x, direction);
            }
        }
        return false;
    }

    public void checkMissingTile(TileList otherTiles) {

        int missingTileX = 0;
        int missingTileY = 0;

        for (Tile tile : tiles) {

            if (tile.getX() == 2*tileSize) {
                missingTileX = tileSize;
                missingTileY = tile.getY();
            }
            if (tile.getX() == Info.WIDTH - 3*tileSize) {
                missingTileX = Info.WIDTH - 2*tileSize;
                missingTileY = tile.getY();
            }
            if (tile.getY() == 2*tileSize) {
                missingTileX = tile.getX();
                missingTileY = tileSize;
            }
            if (tile.getY() == Info.HEIGHT - 3*tileSize) {
                missingTileX = tile.getX();
                missingTileY = Info.HEIGHT - 2*tileSize;
            }
        }
        Tile missingTile = new Tile(getTileSprite(), missingTileX, missingTileY, Info.GREENPATH);
        Tile other = otherTiles.get(otherTiles.size() - 1);

        if (missingTile.isAdjacentTo(other))
            tiles.add(0, missingTile);
    }

    private void adjustMovementOnSoil() {

        int xDeviation = x % size;
        int yDeviation = y % size;

        if (direction == Direction.UP || direction == Direction.DOWN) {

            if (xDeviation < speed)
                x -= xDeviation;
            else if (size - xDeviation < speed)
                x += (size - xDeviation);
            else if (xDeviation < (size / 2))
                x -= speed;
            else
                x += speed;
        }
        if (direction == Direction.LEFT || direction == Direction.RIGHT) {
            
            if (yDeviation < speed)
                y -= yDeviation;
            else if (size - yDeviation < speed)
                y += (size - yDeviation);
            else if (yDeviation < (size / 2))
                y -= speed;
            else
                y += speed;
        }
    }

    

    private void fillUpwards(TileList scanTiles, TileList fillTiles) {

        for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

            for (int y = (Info.HEIGHT - 2*tileSize); y > 0; y -= tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.UP))

                    scanTiles.add(tile);

            }
        }
    }

    private void fillDownwards(TileList scanTiles, TileList fillTiles) {

        for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

            for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.DOWN))

                    scanTiles.add(tile);
            }
        }
    }

    private void fillLeftwards(TileList scanTiles, TileList fillTiles) {
        
        for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = (Info.WIDTH - 2*tileSize); x > 0; x -= tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.LEFT))

                    scanTiles.add(tile);
            }
        }
    }

    private void fillRightwards(TileList scanTiles, TileList fillTiles) {
        
        for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

                Tile tile = new Tile(fillTiles.getTileSprite(), x, y, Info.GRASS);

                if (fillTiles.contains(tile))
                    break;

                if (!this.contains(tile) &&
                    tile.isInsideRegion(this, fillTiles, Direction.RIGHT))

                    scanTiles.add(tile);
            }
        }
    }

    private void fillEnclosedTileSpace(List<Enemy> enemies) {

        TileList scanTiles = new TileList(this.getTileSprite());

        for (int y = tileSize; y < (Info.HEIGHT - tileSize); y += tileSize) {

            for (int x = tileSize; x < (Info.WIDTH - tileSize); x += tileSize) {

                Tile tile = new Tile(this.getTileSprite(), x, y, Info.GRASS);

                boolean isRemovedTile = false;
                for (Enemy enemy : enemies) {

                    if (!(enemy instanceof Beetle))
                        continue;
                    
                    Beetle beetle = (Beetle) enemy;
                    if (beetle.removedTileList().contains(tile))
                        isRemovedTile = true;
                }
                if (isRemovedTile || this.contains(tile))
                    continue;

                int numOfSidesEnclosed = 0;

                if (tile.isInsideRegion(this, Direction.UP))
                    numOfSidesEnclosed++;
                
                if (tile.isInsideRegion(this, Direction.DOWN))
                    numOfSidesEnclosed++;

                if (tile.isInsideRegion(this, Direction.LEFT))
                    numOfSidesEnclosed++;

                if (tile.isInsideRegion(this, Direction.RIGHT))
                    numOfSidesEnclosed++;

                if (numOfSidesEnclosed >= 3)
                    scanTiles.add(tile);
            }
        }
        this.addAll(scanTiles.toArray());
    }

    private void parallelFillForAdjacentToFillTiles(TileList fillTiles,
        TileList secondScan, Tile headTile, Tile tailTile) {

        if (headTile.getY() == tileSize ||
            tailTile.getY() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.DOWN);
        
        if (headTile.getY() == Info.HEIGHT - 2*tileSize ||
            tailTile.getY() == Info.HEIGHT - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.UP);

        if (headTile.getX() == tileSize ||
            tailTile.getX() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.RIGHT);
        
        if (headTile.getX() == Info.WIDTH - 2*tileSize ||
            tailTile.getX() == Info.WIDTH - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.LEFT);
    }

        private void parallelFillForAdjacentToFillTiles(TileList fillTiles,
        TileList secondScan, Tile headTile, Tile tailTile) {

        if (headTile.getY() == tileSize ||
            tailTile.getY() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.DOWN);
        
        if (headTile.getY() == Info.HEIGHT - 2*tileSize ||
            tailTile.getY() == Info.HEIGHT - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.UP);

        if (headTile.getX() == tileSize ||
            tailTile.getX() == tileSize)

            fillInDirection(secondScan, fillTiles, Direction.RIGHT);
        
        if (headTile.getX() == Info.WIDTH - 2*tileSize ||
            tailTile.getX() == Info.WIDTH - 2*tileSize)

            fillInDirection(secondScan, fillTiles, Direction.LEFT);
    }

    
    private boolean updateCollisionWithConcrete(Map<Direction,Tile> boundTiles,
        Tile currentTile, TileList concreteTiles, TileList adjacentTiles) {
        
        Tile first = adjacentTiles.get(0);
        Tile second = adjacentTiles.get(1);
        Tile third = adjacentTiles.get(2);
        Tile fourth = adjacentTiles.get(3);

        boolean collidedWithConcrete = false;

        if (concreteTiles.contains(first)) {

            boundTiles.replace(first.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        if (concreteTiles.contains(second)) {

            boundTiles.replace(second.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        if (concreteTiles.contains(third)) {

            boundTiles.replace(third.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        if (concreteTiles.contains(fourth)) {

            boundTiles.replace(fourth.getOrientation(), currentTile);
            collidedWithConcrete = true;
        }
        return collidedWithConcrete;
    }

    private TileList updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, TileList parameters, TileList adjacentTiles) {

        Tile start = parameters.get(0);
        Tile end = parameters.get(1);
        Tile currentTile = parameters.get(2);
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            start = tiles.get(tiles.size() - 1);
            end = tiles.get(0);
            currentTile = start;
        }
        return new TileList(new Tile[] {start, end, currentTile});
    }

    private boolean[] updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, Tile end, TileList adjacentTiles) {
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            reachedLimit = true;
            collidedWithConcrete = false;
        }
        return new boolean[] {reachedLimit, collidedWithConcrete};
    }

    
    private Tile updateCurrentTile(Tile currentTile, TileList fillTiles, TileList concreteTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        for (Tile tile : adjacentTiles.toArray()) {

            if (fillTiles.get(tile) != null &&
                fillTiles.get(tile).getOrientation() != Direction.NONE &&
                previousDirection != tile.getOppositeOrientation()) {
            
                currentTile = fillTiles.get(tile);
                break;
            }
        }
        for (Tile tile : adjacentTiles.toArray()) {

            if (concreteTiles.get(tile) != null &&
                previousDirection != tile.getOppositeOrientation())
                
                currentTile = concreteTiles.get(tile);
        }
        return currentTile;
    }

    private Direction updatePreviousDirection(TileList fillTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        Tile first = adjacentTiles.get(0);
        Tile second = adjacentTiles.get(1);
        Tile third = adjacentTiles.get(2);
        Tile fourth = adjacentTiles.get(3);

        if (fillTiles.get(first) != null &&
            fillTiles.get(first).getOrientation() != Direction.NONE &&
            previousDirection != first.getOppositeOrientation()) {
            
            previousDirection = first.getOrientation();
        }
        else if (fillTiles.get(second) != null &&
            fillTiles.get(second).getOrientation() != Direction.NONE &&
            previousDirection != second.getOppositeOrientation()) {
            
            previousDirection = second.getOrientation();
        }
        else if (fillTiles.get(third) != null &&
            fillTiles.get(third).getOrientation() != Direction.NONE &&
            previousDirection != third.getOppositeOrientation()) {
            
            previousDirection = third.getOrientation();
        }
        else if (fillTiles.get(fourth) != null &&
            fillTiles.get(fourth).getOrientation() != Direction.NONE &&
            previousDirection != fourth.getOppositeOrientation()) {
            
            previousDirection = fourth.getOrientation();
        }
        return previousDirection;
    }

    private int[][] getPathBounds() {

        int xUpper = tiles.get(0).getX();
        int xLower = tiles.get(0).getX();
        int yUpper = tiles.get(0).getY();
        int yLower = tiles.get(0).getY();

        for (Tile tile : tiles) {

            if (tile.getX() < xUpper)
                xUpper = tile.getX();
            else if (tile.getX() > xLower)
                xLower = tile.getX();

            if (tile.getY() < yUpper)
                yUpper = tile.getY();
            else if (tile.getY() > yLower)
                yLower = tile.getY();
        }
        return new int[][] {{xUpper, xLower}, {yUpper, yLower}};
    }

    private Tile updateCurrentTile(Tile currentTile, TileList fillTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        for (Tile tile : adjacentTiles.toArray()) {

            if (fillTiles.get(tile) != null &&
                fillTiles.get(tile).getOrientation() != Direction.NONE &&
                previousDirection != tile.getOppositeOrientation()) {
            
                currentTile = fillTiles.get(tile);
                break;
            }
        }
        return currentTile;
    }

    private Direction updatePreviousDirection(TileList fillTiles,
        TileList adjacentTiles, Direction previousDirection) {
        
        Tile first = adjacentTiles.get(0);
        Tile second = adjacentTiles.get(1);
        Tile third = adjacentTiles.get(2);
        Tile fourth = adjacentTiles.get(3);

        if (fillTiles.get(first) != null &&
            fillTiles.get(first).getOrientation() != Direction.NONE &&
            previousDirection != first.getOppositeOrientation()) {
            
            previousDirection = first.getOrientation();
        }
        else if (fillTiles.get(second) != null &&
            fillTiles.get(second).getOrientation() != Direction.NONE &&
            previousDirection != second.getOppositeOrientation()) {
            
            previousDirection = second.getOrientation();
        }
        else if (fillTiles.get(third) != null &&
            fillTiles.get(third).getOrientation() != Direction.NONE &&
            previousDirection != third.getOppositeOrientation()) {
            
            previousDirection = third.getOrientation();
        }
        else if (fillTiles.get(fourth) != null &&
            fillTiles.get(fourth).getOrientation() != Direction.NONE &&
            previousDirection != fourth.getOppositeOrientation()) {
            
            previousDirection = fourth.getOrientation();
        }
        return previousDirection;
    }

    private boolean updateCollisionWithConcrete(TileList concreteTiles,
        TileList adjacentTiles) {

        boolean collidedWithConcrete = false;
        
        for (Tile tile : adjacentTiles.toArray()) {

            if (concreteTiles.contains(tile)) {

                collidedWithConcrete = true;
                break;
            }
        }
        return collidedWithConcrete;
    }

    private TileList updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, TileList parameters, TileList adjacentTiles) {

        Tile start = parameters.get(0);
        Tile end = parameters.get(1);
        Tile currentTile = parameters.get(2);
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            start = tiles.get(tiles.size() - 1);
            end = tiles.get(0);
            currentTile = start;
        }
        return new TileList(new Tile[] {start, end, currentTile});
    }

    private boolean[] updateParameters(boolean collidedWithConcrete,
        boolean reachedLimit, Tile end, TileList adjacentTiles) {
        
        if (!reachedLimit && (collidedWithConcrete ||
            adjacentTiles.contains(end))) {

            reachedLimit = true;
            collidedWithConcrete = false;
        }
        return new boolean[] {reachedLimit, collidedWithConcrete};
    }

    public TileList getBounds(TileList fillTiles,
        TileList concreteTiles, Direction direction) {
        
        TileList bounds = new TileList();
        bounds.addAll(this, false);

        Tile current = tiles.get(0);
        Tile end = tiles.get(tiles.size() - 1);

        Direction previousDirection = Direction.NONE;
        boolean collidedWithConcrete = false;
        boolean reachedLimit = false;

        while (true) {

            System.out.println("Current tile: "+current);

            TileList adjacentTiles = getAdjacentTiles(current, direction);

            if (reachedLimit && (collidedWithConcrete ||
                adjacentTiles.contains(end))) {
                
                System.out.println("Reached the end");
                break;
            }
            for (Tile tile : adjacentTiles.toArray()) {

                if (fillTiles.get(tile) != null &&
                    fillTiles.get(tile).getOrientation() != Direction.NONE &&
                    previousDirection != tile.getOppositeOrientation()) {
                
                    current = tile;
                    bounds.add(current, false);
                    previousDirection = tile.getOrientation();
                    break;
                }
            }
            for (Tile tile : adjacentTiles.toArray()) {

                if (concreteTiles.contains(tile)) {
                    
                    collidedWithConcrete = true;
                    break;
                }
            }
            if (!reachedLimit && (collidedWithConcrete ||
                adjacentTiles.contains(end))) {

                current = tiles.get(tiles.size() - 1);
                end = tiles.get(0);
                reachedLimit = true;
                collidedWithConcrete = false;
            }
        }
        return bounds;
    }

    private TileList getAdjacentTiles(Tile currentTile, Direction direction) {

        Tile first = currentTile.getAdjacentTile(direction.flip());
        Tile second = currentTile.getAdjacentTile(first.getOppositeOrientation());
        Tile third = currentTile.getAdjacentTile(second.getPerpendicularOrientation());
        Tile fourth = currentTile.getAdjacentTile(first.getPerpendicularOrientation());

        return new TileList(new Tile[] {first, second, third, fourth});
    }

    private void fillForOppositeOrientiation(TileList fillTiles,
        TileList concreteTiles, Tile headTile, Tile tailTile, List<Enemy> enemies) {

        TileList scan1 = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());
        TileList scan2 = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());
        TileList scan3 = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());

        TileList bounds1 = getBounds(fillTiles, concreteTiles,
            headTile.getOrientation());
        // int[][] bounds2 = getBounds(fillTiles, concreteTiles,
        //     headTile.getPerpendicularOrientation());
        // int[][] bounds3 = getBounds(fillTiles, concreteTiles,
        //     tailTile.getPerpendicularOrientation());
        System.out.println(bounds1);

        // System.out.printf("%s: [%d,%d],[%d,%d]%n", headTile.getOrientation(), bounds1[0][0], bounds1[0][1], bounds1[1][0], bounds1[1][1]);
        // System.out.printf("%s: [%d,%d],[%d,%d]%n", headTile.getPerpendicularOrientation(), bounds2[0][0], bounds2[0][1], bounds2[1][0], bounds2[1][1]);
        // System.out.printf("%s: [%d,%d],[%d,%d]%n", tailTile.getPerpendicularOrientation(), bounds3[0][0], bounds3[0][1], bounds3[1][0], bounds3[1][1]);

        // fillInDirection(scan1, fillTiles, bounds1,
        //     headTile.getOrientation());
        // fillInDirection(scan2, fillTiles, bounds2,
        //     headTile.getPerpendicularOrientation());
        // fillInDirection(scan3, fillTiles, bounds3,
        //     tailTile.getPerpendicularOrientation());

        TileList defaultScan = new TileList();
        
        for (Tile tile : scan1.toArray()) {

            if (scan2.contains(tile) && scan3.contains(tile))
                defaultScan.add(tile, false);
        }
        for (Enemy enemy : enemies) {

            if (enemy.isInsideRegion(defaultScan)) {
                defaultScan.hide();
            }
        }
        fillTiles.addAll(defaultScan, isOverriding);
    }

    private void fillForPerpendicularOrientiation(TileList fillTiles,
        TileList concreteTiles, Tile headTile, Tile tailTile, List<Enemy> enemies) {

        TileList firstScan = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());
        TileList secondScan = new TileList(fillTiles.getTileSprite(),
            fillTiles.getTileName());

        TileList firstBounds = getBounds(fillTiles, concreteTiles,
            headTile.getOrientation());
        // int[][] secondBounds = getBounds(fillTiles, concreteTiles,
        //     tailTile.getOppositeOrientation());
        System.out.println(firstBounds);

        // System.out.printf("%s: [%d,%d],[%d,%d]%n", headTile.getOrientation(), firstBounds[0][0], firstBounds[0][1], firstBounds[1][0], firstBounds[1][1]);
        // System.out.printf("%s: [%d,%d],[%d,%d]%n", tailTile.getOppositeOrientation(), secondBounds[0][0], secondBounds[0][1], secondBounds[1][0], secondBounds[1][1]);

        // fillInDirection(firstScan, fillTiles, firstBounds,
        //     headTile.getOrientation());
        // fillInDirection(secondScan, fillTiles, secondBounds,
        //     tailTile.getOppositeOrientation());

        TileList scanTiles = new TileList();

        for (Tile tile : firstScan.toArray()) {

            if (secondScan.contains(tile))
                scanTiles.add(tile, false);
        }
        for (Enemy enemy : enemies) {

            if (enemy.isInsideRegion(scanTiles)) {
                scanTiles.hide();
            }
        }
        fillTiles.addAll(scanTiles, isOverriding);
    }

}